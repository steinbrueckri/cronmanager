package main

import (
	"os"
	"path/filepath"
	"regexp"
	"testing"
	"time"
)

// Note: G304 (file inclusion via variable) warnings are suppressed in tests
// because all file paths come from controlled temp directories created by the tests

func TestGetExporterPath(t *testing.T) {
	tests := []struct {
		name     string
		jobName  string
		envValue string
		envSet   bool
		want     string
	}{
		{
			name:     "uses environment variable when set",
			jobName:  "testjob",
			envValue: "/custom/path",
			envSet:   true,
			want:     "/custom/path/testjob.prom",
		},
		{
			name:     "uses default path when env not set",
			jobName:  "testjob",
			envValue: "",
			envSet:   false,
			want:     "/var/lib/node_exporter/testjob.prom",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Setup
			if tt.envSet {
				if err := os.Setenv("COLLECTOR_TEXTFILE_PATH", tt.envValue); err != nil {
					t.Fatalf("Failed to set env: %v", err)
				}
				defer func() {
					if err := os.Unsetenv("COLLECTOR_TEXTFILE_PATH"); err != nil {
						t.Errorf("Failed to unset env: %v", err)
					}
				}()
			} else {
				if err := os.Unsetenv("COLLECTOR_TEXTFILE_PATH"); err != nil {
					t.Fatalf("Failed to unset env: %v", err)
				}
			}

			// Test
			got := getExporterPath(tt.jobName)
			if got != tt.want {
				t.Errorf("getExporterPath() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestWriteToExporter(t *testing.T) {
	// Create temp directory for test files
	tmpDir, err := os.MkdirTemp("", "cronmanager-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer func() {
		if err := os.RemoveAll(tmpDir); err != nil {
			t.Errorf("Failed to remove temp dir: %v", err)
		}
	}()

	// Set env to use temp directory
	if err := os.Setenv("COLLECTOR_TEXTFILE_PATH", tmpDir); err != nil {
		t.Fatalf("Failed to set env: %v", err)
	}
	defer func() {
		if err := os.Unsetenv("COLLECTOR_TEXTFILE_PATH"); err != nil {
			t.Errorf("Failed to unset env: %v", err)
		}
	}()

	jobName := "testjob"
	expectedPath := filepath.Join(tmpDir, jobName+".prom")

	tests := []struct {
		name      string
		jobName   string
		label     string
		metric    string
		wantRegex string
	}{
		{
			name:      "writes run metric",
			jobName:   jobName,
			label:     "run",
			metric:    "1",
			wantRegex: `cronjob\{name="testjob",dimension="run"\} 1`,
		},
		{
			name:      "writes failed metric",
			jobName:   jobName,
			label:     "failed",
			metric:    "0",
			wantRegex: `cronjob\{name="testjob",dimension="failed"\} 0`,
		},
		{
			name:      "writes duration metric",
			jobName:   jobName,
			label:     "duration",
			metric:    "42",
			wantRegex: `cronjob\{name="testjob",dimension="duration"\} 42`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Write metric
			writeToExporter(tt.jobName, tt.label, tt.metric)

			// Read file
			content, err := os.ReadFile(expectedPath) // #nosec G304
			if err != nil {
				t.Fatalf("Failed to read exported file: %v", err)
			}

			// Check content
			matched, err := regexp.Match(tt.wantRegex, content)
			if err != nil {
				t.Fatalf("Invalid regex: %v", err)
			}
			if !matched {
				t.Errorf("Expected content to match %q, got:\n%s", tt.wantRegex, content)
			}

			// Check for required headers
			if !regexp.MustCompile(`# HELP cronjob metric generated by cronmanager`).Match(content) {
				t.Error("Missing HELP header")
			}
			if !regexp.MustCompile(`# TYPE cronjob gauge`).Match(content) {
				t.Error("Missing TYPE header")
			}
		})
	}
}

func TestWriteToExporterMultipleMetrics(t *testing.T) {
	// Create temp directory for test files
	tmpDir, err := os.MkdirTemp("", "cronmanager-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer func() {
		if err := os.RemoveAll(tmpDir); err != nil {
			t.Errorf("Failed to remove temp dir: %v", err)
		}
	}()

	if err := os.Setenv("COLLECTOR_TEXTFILE_PATH", tmpDir); err != nil {
		t.Fatalf("Failed to set env: %v", err)
	}
	defer func() {
		if err := os.Unsetenv("COLLECTOR_TEXTFILE_PATH"); err != nil {
			t.Errorf("Failed to unset env: %v", err)
		}
	}()

	jobName := "multijob"
	expectedPath := filepath.Join(tmpDir, jobName+".prom")

	// Write multiple metrics
	writeToExporter(jobName, "run", "1")
	writeToExporter(jobName, "failed", "0")
	writeToExporter(jobName, "duration", "123")

	// Read file
	content, err := os.ReadFile(expectedPath) // #nosec G304
	if err != nil {
		t.Fatalf("Failed to read exported file: %v", err)
	}

	contentStr := string(content)

	// Check all metrics are present
	expectedMetrics := []string{
		`cronjob{name="multijob",dimension="run"} 1`,
		`cronjob{name="multijob",dimension="failed"} 0`,
		`cronjob{name="multijob",dimension="duration"} 123`,
	}

	for _, expected := range expectedMetrics {
		if !regexp.MustCompile(regexp.QuoteMeta(expected)).MatchString(contentStr) {
			t.Errorf("Expected to find %q in content:\n%s", expected, contentStr)
		}
	}

	// Ensure only one set of headers
	helpCount := regexp.MustCompile(`# HELP cronjob`).FindAllStringIndex(contentStr, -1)
	if len(helpCount) != 1 {
		t.Errorf("Expected 1 HELP header, found %d", len(helpCount))
	}
}

func TestWriteToExporterUpdateMetric(t *testing.T) {
	// Create temp directory for test files
	tmpDir, err := os.MkdirTemp("", "cronmanager-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer func() {
		if err := os.RemoveAll(tmpDir); err != nil {
			t.Errorf("Failed to remove temp dir: %v", err)
		}
	}()

	if err := os.Setenv("COLLECTOR_TEXTFILE_PATH", tmpDir); err != nil {
		t.Fatalf("Failed to set env: %v", err)
	}
	defer func() {
		if err := os.Unsetenv("COLLECTOR_TEXTFILE_PATH"); err != nil {
			t.Errorf("Failed to unset env: %v", err)
		}
	}()

	jobName := "updatejob"
	expectedPath := filepath.Join(tmpDir, jobName+".prom")

	// Write initial metric
	writeToExporter(jobName, "duration", "10")

	// Update the same metric
	writeToExporter(jobName, "duration", "20")

	// Read file
	content, err := os.ReadFile(expectedPath) // #nosec G304
	if err != nil {
		t.Fatalf("Failed to read exported file: %v", err)
	}

	contentStr := string(content)

	// Check updated value is present
	if !regexp.MustCompile(`cronjob\{name="updatejob",dimension="duration"\} 20`).MatchString(contentStr) {
		t.Errorf("Expected updated metric with value 20, got:\n%s", contentStr)
	}

	// Ensure old value is NOT present
	if regexp.MustCompile(`cronjob\{name="updatejob",dimension="duration"\} 10`).MatchString(contentStr) {
		t.Errorf("Old metric value should be replaced, got:\n%s", contentStr)
	}

	// Count occurrences of the metric (should be exactly 1)
	matches := regexp.MustCompile(`cronjob\{name="updatejob",dimension="duration"\}`).FindAllStringIndex(contentStr, -1)
	if len(matches) != 1 {
		t.Errorf("Expected exactly 1 occurrence of the metric, found %d", len(matches))
	}
}

func TestIdleWait(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping slow test in short mode")
	}

	tests := []struct {
		name          string
		startOffset   time.Duration
		expectedSleep time.Duration
		tolerance     time.Duration
	}{
		{
			name:          "doesn't wait when job exceeds idle time",
			startOffset:   65 * time.Second,
			expectedSleep: 0,
			tolerance:     500 * time.Millisecond,
		},
		{
			name:          "waits short time when job is near idle limit",
			startOffset:   58 * time.Second,
			expectedSleep: 2 * time.Second,
			tolerance:     500 * time.Millisecond,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create a start time in the past
			jobStart := time.Now().Add(-tt.startOffset)

			// Measure how long idleWait takes
			start := time.Now()
			idleWait(jobStart)
			elapsed := time.Since(start)

			// Check if elapsed time is within tolerance
			if elapsed < tt.expectedSleep-tt.tolerance || elapsed > tt.expectedSleep+tt.tolerance {
				t.Errorf("idleWait() took %v, expected %v (Â±%v)", elapsed, tt.expectedSleep, tt.tolerance)
			}
		})
	}
}

func TestIdleWaitCalculation(t *testing.T) {
	// Fast unit test that verifies the logic without actually waiting
	tests := []struct {
		name        string
		startOffset int64
		shouldWait  bool
	}{
		{
			name:        "should wait when job is quick",
			startOffset: 10,
			shouldWait:  true,
		},
		{
			name:        "should not wait when exceeds idle time",
			startOffset: 65,
			shouldWait:  false,
		},
		{
			name:        "at boundary",
			startOffset: 60,
			shouldWait:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			jobStart := time.Now().Add(-time.Duration(tt.startOffset) * time.Second)
			diff := idleForSeconds - (time.Now().Unix() - jobStart.Unix())

			if tt.shouldWait && diff <= 0 {
				t.Errorf("Expected to wait, but diff is %d", diff)
			}
			if !tt.shouldWait && diff > 0 {
				t.Errorf("Expected not to wait, but diff is %d", diff)
			}
		})
	}
}

func TestWriteToExporterConcurrent(t *testing.T) {
	// Test that concurrent writes don't corrupt the file
	tmpDir, err := os.MkdirTemp("", "cronmanager-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer func() {
		if err := os.RemoveAll(tmpDir); err != nil {
			t.Errorf("Failed to remove temp dir: %v", err)
		}
	}()

	if err := os.Setenv("COLLECTOR_TEXTFILE_PATH", tmpDir); err != nil {
		t.Fatalf("Failed to set env: %v", err)
	}
	defer func() {
		if err := os.Unsetenv("COLLECTOR_TEXTFILE_PATH"); err != nil {
			t.Errorf("Failed to unset env: %v", err)
		}
	}()

	jobName := "concurrentjob"
	expectedPath := filepath.Join(tmpDir, jobName+".prom")

	// Write metrics concurrently
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func(val int) {
			writeToExporter(jobName, "duration", string(rune('0'+val)))
			done <- true
		}(i)
	}

	// Wait for all goroutines
	for i := 0; i < 10; i++ {
		<-done
	}

	// File should exist and be valid
	content, err := os.ReadFile(expectedPath) // #nosec G304
	if err != nil {
		t.Fatalf("Failed to read exported file: %v", err)
	}

	// Check structure is still valid
	if !regexp.MustCompile(`# HELP cronjob metric generated by cronmanager`).Match(content) {
		t.Error("Missing HELP header after concurrent writes")
	}
	if !regexp.MustCompile(`# TYPE cronjob gauge`).Match(content) {
		t.Error("Missing TYPE header after concurrent writes")
	}
	if !regexp.MustCompile(`cronjob\{name="concurrentjob",dimension="duration"\}`).Match(content) {
		t.Error("Missing metric after concurrent writes")
	}
}

func TestWriteToExporterSpecialCharacters(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "cronmanager-test-*")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer func() {
		if err := os.RemoveAll(tmpDir); err != nil {
			t.Errorf("Failed to remove temp dir: %v", err)
		}
	}()

	if err := os.Setenv("COLLECTOR_TEXTFILE_PATH", tmpDir); err != nil {
		t.Fatalf("Failed to set env: %v", err)
	}
	defer func() {
		if err := os.Unsetenv("COLLECTOR_TEXTFILE_PATH"); err != nil {
			t.Errorf("Failed to unset env: %v", err)
		}
	}()

	// Test with job name containing special regex characters
	jobName := "test.job-name_123"
	expectedPath := filepath.Join(tmpDir, jobName+".prom")

	writeToExporter(jobName, "run", "1")

	content, err := os.ReadFile(expectedPath) // #nosec G304
	if err != nil {
		t.Fatalf("Failed to read exported file: %v", err)
	}

	expectedMetric := `cronjob{name="test.job-name_123",dimension="run"} 1`
	if !regexp.MustCompile(regexp.QuoteMeta(expectedMetric)).Match(content) {
		t.Errorf("Expected to find %q in content:\n%s", expectedMetric, content)
	}
}
